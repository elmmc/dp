/*
题目背景
你知道食物链吗？Delia 生物考试的时候，数食物链条数的题目全都错了，因为她总是重复数了几条或漏掉了几条。于是她来就来求助你，然而你也不会啊！写一个程序来帮帮她吧。

题目描述
给你一个食物网，你要求出这个食物网中最大食物链的数量。

（这里的“最大食物链”，指的是生物学意义上的食物链，即最左端是不会捕食其他生物的生产者，最右端是不会被其他生物捕食的消费者。）

Delia 非常急，所以你只有 11 秒的时间。

由于这个结果可能过大，你只需要输出总数模上 8011200280112002 的结果。

输入格式
第一行，两个正整数 n、mn、m，表示生物种类 nn 和吃与被吃的关系数 mm。

接下来 mm 行，每行两个正整数，表示被吃的生物A和吃A的生物B。

输出格式
一行一个整数，为最大食物链数量模上 8011200280112002 的结果。
*/

/*
思路：
从食物链的最底层开始向上dp，dp[i]代表到这里为止有几条食物链，那么dp[i]=dp[i-1]+dp[i],这个动物的dp值等于自身加上被自己吃的动物的dp值。
那么答案就是食物链最顶层的动物dp值之和。
所以，现在就要找到食物链最顶层和最底层的动物，我们可以用两个数组来分别记录每个动物的入度和出度，入度为0，说明是最底层，出度为0，说明是最顶层。
动物之间的扑食关系是一条有向边，我们可以用邻接表来储存它，（书上用的是链表，为了方便遍历，可以用vector储存边），如何用拓扑排序，将整个食物链储存到一个数组中去。
最后在从底层开始dp就行。
*/

```
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int mod=80112002;
const int maxn=5e3+5;
int n,m,ru[maxn],chu[maxn];
int dp[maxn];
vector<int>V[maxn];
queue<int>Q;
int main() {
    cin>>n>>m;
    for(int i=1; i<=m; i++) {
        int a,b;
        cin>>a>>b;
        ru[b]++;
        chu[a]++;
        V[a].push_back(b);
    }
    for(int i=1; i<=n; i++) {
        if(ru[i]==0) {
            dp[i]=1;
            Q.push(i);
        }
    }
    while(!Q.empty()) {
        int t=Q.front();
        Q.pop();
        for(int i=0; i<V[t].size(); i++) {
            int next=V[t][i];
            ru[next]--;
            dp[next]=(dp[next]+dp[t])%mod;
            if(ru[next]==0)
                Q.push(V[t][i]);
        }
    }
    int res=0;
    for(int i=1; i<=n; i++) {
        if(chu[i]==0) {
            res+=dp[i];
            res%=mod;
        }
    }
    cout<<res<<endl;
}
```

/*
题目背景
此题为纪念 LiYuxiang 而生。

题目描述
LiYuxiang 是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同种类的草药，采每一种都需要一些时间，每一种也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是 LiYuxiang，你能完成这个任务吗？

此题和原题的不同点：

11. 每种草药可以无限制地疯狂采摘。

22. 药的种类眼花缭乱，采药时间好长好长啊！师傅等得菊花都谢了！

输入格式
输入第一行有两个整数，分别代表总共能够用来采药的时间 tt 和代表山洞里的草药的数目 mm。

第 22 到第 (m + 1)(m+1) 行，每行两个整数，第 (i + 1)(i+1) 行的整数 a_i, b_ia i​	,b i​	分别表示采摘第 ii 种草药的时间和该草药的价值。

输出格式
输出一行，这一行只包含一个整数，表示在规定的时间内，可以采到的草药的最大总价值。
*/

/*
  思路：
  这道题跟采药那题非常相似，只不过每种草药可以无限制地疯狂采摘。状态转移方程还是一样的。
  dp[j]=max(dp[j],dp[j-a[i]]+b[i])，不过，遍历时间的时候要从小到大遍历，这样中途转移时，可以重复加。
*/

```
#include<iostream>
#include<cstring>
using namespace std;
long long int a[10005],b[10005],dp[10000005];
int main() {
    int T,M;
    cin>>T>>M;
    for(int i=1; i<=M; i++) {
        cin>>a[i]>>b[i];
    }
    for(int i=1; i<=M; i++) {
        for(int j=a[i];j<=T; j++) {
            dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
        }
    }
    cout<<dp[T];
}

```
