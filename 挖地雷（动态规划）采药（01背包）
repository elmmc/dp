/*
## 题目描述
在一个地图上有NN个地窖(N \le 20)(N≤20)，每个地窖中埋有一定数量的地雷。
同时，给出地窖之间的连接路径。当地窖及其连接的数据给出之后，某人可以从任一处开始挖地雷，然后可以沿着指出的连接往下挖（仅能选择一条路径），当无连接时挖地雷工作结束。
设计一个挖地雷的方案，使某人能挖到最多的地雷。

## 输入格式
有若干行。

第11行只有一个数字，表示地窖的个数NN。

第22行有NN个数，分别表示每个地窖中的地雷个数。

第33行至第N+1N+1行表示地窖之间的连接情况：

第33行有n-1n−1个数（00或11），表示第一个地窖至第22个、第33个、…、第nn个地窖有否路径连接。如第33行为1 1 0 0 0 … 011000…0，则表示第11个地窖至第22个地窖有路径，至第33个地窖有路径，至第44个地窖、第55个、…、第nn个地窖没有路径。

第44行有n-2n−2个数，表示第二个地窖至第33个、第44个、…、第nn个地窖有否路径连接。

… …

第n+1n+1行有11个数，表示第n-1n−1个地窖至第nn个地窖有否路径连接。（为00表示没有路径，为11表示有路径）。
输出格式
有两行

第一行表示挖得最多地雷时的挖地雷的顺序，各地窖序号间以一个空格分隔，不得有多余的空格。

第二行只有一个数，表示能挖到的最多地雷数。

## 思路
这道题我们可以用一个dp数组，dp[i]表示以第i个结尾最大的地雷数。
然后状态方程就很简单了，就是dp[i]=max（dp[i],dp[j]）+地雷数
路径的话，我用一个path数组来储存，记录每个点的前一个的下标。
*/

## 代码
```
#include<iostream>
using namespace std;
int path[21],S[21][21],num[21];
int dp[21];
void print(int x) {
    if(!path[x]) {
        cout<<x;
        return;
    }
    print(path[x]);
    cout<<" "<<x;
}
int main() {
    int N;
    cin>>N;
    for(int i=1; i<=N; i++) {
        cin>>num[i];
    }
    for(int i=1; i<=N; i++) {
        for(int j=i+1; j<=N; j++) {
            cin>>S[i][j];
            S[j][i]=S[i][j];
        }
    }
    int res=0,F;
    for(int i=1; i<=N; i++) {
        for(int j=1; j<=N; j++) {
            if(S[j][i]&&dp[j]>dp[i]) {
                dp[i]=dp[j];
                path[i]=j;
            }
        }
        dp[i]+=num[i];
        if(dp[i]>res) {
            res=dp[i];
            F=i;
        }
    }
    print(F);
    cout<<endl;
    cout<<res<<endl;
}
```
    
/*
## 题目描述
辰辰是个天资聪颖的孩子，他的梦想是成为世界上最伟大的医师。为此，他想拜附近最有威望的医师为师。医师为了判断他的资质，给他出了一个难题。医师把他带到一个到处都是草药的山洞里对他说：“孩子，这个山洞里有一些不同的草药，采每一株都需要一些时间，每一株也有它自身的价值。我会给你一段时间，在这段时间里，你可以采到一些草药。如果你是一个聪明的孩子，你应该可以让采到的草药的总价值最大。”

如果你是辰辰，你能完成这个任务吗？

## 输入格式
第一行有 22 个整数 TT（1 \le T \le 10001≤T≤1000）和 MM（1 \le M \le 1001≤M≤100），用一个空格隔开，TT 代表总共能够用来采药的时间，MM 代表山洞里的草药的数目。

接下来的 MM 行每行包括两个在 11 到 100100 之间（包括 11 和 100100）的整数，分别表示采摘某株草药的时间和这株草药的价值。

## 输出格式
输出在规定的时间内可以采到的草药的最大总价值。



## 思路
这是一道简单的01背包题目，用滚动数组dp[i],表示时间为i的时候能采的药的最大值。
a[i]表示时间，b[i]表示价值。
状态方程为 dp[j]=max(dp[j],dp[j-a[i]]+b[i])
最后dp[T]就是我们要的答案了
*/

## 代码
```
#include<iostream>
#include<cstring>
using namespace std;
int a[105],b[105],dp[1005];
int main() {
    int T,M;
    cin>>T>>M;
    for(int i=1; i<=M; i++) {
        cin>>a[i]>>b[i];
    }
    for(int i=1; i<=M; i++) {
        for(int j=T; j>=a[i]; j--) {
            dp[j]=max(dp[j],dp[j-a[i]]+b[i]);
        }
    }
    cout<<dp[T];
}

