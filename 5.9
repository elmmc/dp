/*
题目描述
观察下面的数字金字塔。

写一个程序来查找从最高点到底部任意处结束的路径，使路径经过数字的和最大。每一步可以走到左下方的点也可以到达右下方的点。

        7 
      3   8 
    8   1   0 
  2   7   4   4 
4   5   2   6   5 
在上面的样例中,从 7 \to 3 \to 8 \to 7 \to 57→3→8→7→5 的路径产生了最大

输入格式
第一个行一个正整数 rr ,表示行的数目。

后面每行为这个数字金字塔特定行包含的整数。

输出格式
单独的一行,包含那个可能得到的最大的和。
*/
/*
这道题就是一个简单的dp，我们选择从下往上更新最优状态，因为这样状态转移就是
 dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+s[i][j];
这样最优解就在第一个，dp[1][1]。
从上往下更新的话，就会有特殊情况，s[2][1]只有一个来源dp[1][1]。
*/
代码
···#include<iostream>
using namespace std;
int s[1005][1005],dp[1005][1005];
int main() {
    int n;
    cin>>n;
    for(int i=1; i<=n; i++) {
        for(int j=1; j<=i; j++) {
            cin>>s[i][j];
            dp[i][j]=s[i][j];
        }
    }
    for(int i=n; i>=1; i--) {
        for(int j=1; j<=n; j++) {
            dp[i][j]=max(dp[i+1][j],dp[i+1][j+1])+s[i][j];
        }
    }
    cout<<dp[1][1]<<endl;
}···
